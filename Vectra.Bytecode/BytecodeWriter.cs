using System.Diagnostics.CodeAnalysis;
using System.Text;
using Vectra.Bytecode.Models;

namespace Vectra.Bytecode;

/// <summary>
/// The <see cref="BytecodeWriter"/> class provides functionality for writing bytecode programs
/// generated in the Vectra Bytecode system to a file. It encapsulates methods for preparing
/// and writing program metadata, constants, and execution spaces.
/// </summary>
[ExcludeFromCodeCoverage]
public class BytecodeWriter
{
    /// <summary>
    /// Writes a VbcProgram to a bytecode file on disk, including its header, constants, and execution details.
    /// </summary>
    /// <param name="program">The <see cref="VbcProgram"/> containing metadata, constants, and spaces to be written to the bytecode file.</param>
    /// <returns>The file path of the generated bytecode file as a string.</returns>
    public static string WriteToFile(VbcProgram program)
    {
        using var stream = CreateStream(program.ModuleName);
        using var writer = new BinaryWriter(stream);
        // Write header (magic, version, ets.)
        WriteHeader(writer);
        
        // write entry info (entry method name length, entry method name)
        WriteEntryInfo(program.ModuleType, program.EntryPointMethod, writer);
        
        // write constant pool (constant pool length, constants)
        // Constants will be type formatted. numbers and bools will be written as-is. strings will be written as a length followed by the string.
        WriteConstants(program.Constants, writer);
        
        // Write spaces (space count, spaces)
        WriteSpace(program.RootSpace, writer);
        
        return stream.Name;
    }

    /// <summary>
    /// Creates a writable file stream for the specified module name,
    /// ensuring the file is created in the current directory with the extension ".vbc".
    /// </summary>
    /// <param name="moduleName">The name of the module for which the file stream is created, excluding the extension.</param>
    /// <returns>A <see cref="FileStream"/> object set to create and write to the specified file.</returns>
    private static FileStream CreateStream(string moduleName)
    {
        // Considerations for future versions:
        // - Add support for writing to a specified path
        // - Change the default output path to be in the project's bin directory
        var path = Path.Combine(Directory.GetCurrentDirectory(), $"{moduleName}.vbc");
        return new FileStream(path, FileMode.Create, FileAccess.Write);
    }

    /// <summary>
    /// Writes the header information for a bytecode file, including the magic number and version.
    /// </summary>
    /// <param name="writer">The <see cref="BinaryWriter"/> to use for writing the header data.</param>
    private static void WriteHeader(BinaryWriter writer)
    {
        // Write Magic
        writer.Write((byte)'V');
        writer.Write((byte)'B');
        writer.Write((byte)'C');
        // Write Version
        writer.Write((byte)0x01);
    }

    /// <summary>
    /// Writes entry point information to the binary writer based on the specified module type.
    /// If the module type is executable, the entry point method name and its length are written.
    /// If the module type is a library, no entry point is written, and a length of 0 is recorded.
    /// </summary>
    /// <param name="moduleType">The type of the module, indicating whether it is a library or an executable.</param>
    /// <param name="entryPoint">The name of the entry point method. This must not be null for executable modules.</param>
    /// <param name="writer">The <see cref="BinaryWriter"/> instance used to write the entry point information to the output stream.</param>
    /// <exception cref="ArgumentNullException">Thrown when the entryPoint is null for an executable module.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when the module type is not recognized.</exception>
    private static void WriteEntryInfo(VbcModuleType moduleType, string? entryPoint, BinaryWriter writer)
    {
        switch (moduleType)
        {
            case VbcModuleType.Executable:
                ArgumentNullException.ThrowIfNull(entryPoint);
                var bytes = Encoding.UTF8.GetBytes(entryPoint);
                // Write entry point name length
                writer.Write((byte)bytes.Length);
                // Write entry point name
                writer.Write(bytes);
                break;
            case VbcModuleType.Library:
                writer.Write((byte)0);
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(moduleType), moduleType, null);
        }
    }

    /// <summary>
    /// Writes the constant pool to the specified <see cref="BinaryWriter"/> stream,
    /// including the number of constants and their serialized values in the defined format.
    /// </summary>
    /// <param name="constants">The list of constants to be written, where each constant can be an integer, boolean, or string.</param>
    /// <param name="writer">The <see cref="BinaryWriter"/> used to write the serialized constants to an output stream.</param>
    private static void WriteConstants(List<object> constants, BinaryWriter writer)
    {
        writer.Write(constants.Count);
        foreach (var constant in constants)
        {
            WriteConstant(constant, writer);
        }
    }

    /// <summary>
    /// Writes a single constant value to the specified <see cref="BinaryWriter"/> stream in the defined format.
    /// </summary>
    /// <param name="value">The constant value to be written, which can be an integer, boolean, or string.</param>
    /// <param name="writer">The <see cref="BinaryWriter"/> used to write the constant value to an output stream.</param>
    /// <exception cref="InvalidOperationException">Thrown when the type of the constant is unsupported.</exception>
    private static void WriteConstant(object value, BinaryWriter writer)
    {
        // TODO: Update int writing to support all number types (may need to determine the type under the hood and treat as number)
        switch (value)
        {
            case int i:
                writer.Write((byte)1); // type tag: int
                writer.Write(i);
                break;
            case bool b:
                writer.Write((byte)2); // type tag: bool
                writer.Write(b);
                break;
            case string s:
                writer.Write((byte)3); // type tag: string
                writer.WriteString(s);
                break;
            default:
                throw new InvalidOperationException($"Invalid constant type: {value.GetType().Name}");
        }
    }

    /// <summary>
    /// Writes the hierarchical structure of a <see cref="VbcSpace"/> to the provided <see cref="BinaryWriter"/> stream,
    /// including its name, classes, and subspaces.
    /// </summary>
    /// <param name="space">The <see cref="VbcSpace"/> instance representing the namespace-like structure to write.</param>
    /// <param name="writer">The <see cref="BinaryWriter"/> used to write the bytecode representation of the space.</param>
    private static void WriteSpace(VbcSpace space, BinaryWriter writer)
    {
        // write space name
        writer.WriteString(space.Name);

        var classes = space.Types.OfType<VbcClass>().ToList();
        
        // write class count
        writer.Write(classes.Count);
        foreach (var cls in classes)
            WriteClass(cls, writer);
        
        // write subspaces
        writer.Write(space.Subspaces.Count);
        foreach (var subspace in space.Subspaces)
            WriteSpace(subspace, writer);
    }

    /// <summary>
    /// Serializes the specified VbcClass object into a binary format and writes it using the provided BinaryWriter.
    /// </summary>
    /// <param name="cls">The instance of <see cref="VbcClass"/> to be serialized, containing the class name and its methods.</param>
    /// <param name="writer">The <see cref="BinaryWriter"/> used to write the binary data for the class.</param>
    private static void WriteClass(VbcClass cls, BinaryWriter writer)
    {
        writer.WriteString(cls.Name);
        
        writer.Write(cls.Fields.Count);
        foreach (var field in cls.Fields)
        {
            WriteField(field, writer);
        }
        
        writer.Write(cls.Properties.Count);
        foreach (var prop in cls.Properties)
        {
            WriteProperty(prop, writer);
        }
        
        writer.Write(cls.Methods.Count);
        foreach (var method in cls.Methods)
            WriteMethod(method, writer);
    }

    private static void WriteField(VbcField field, BinaryWriter writer)
    {
        writer.WriteString(field.Name);
        writer.WriteString(field.TypeName ?? ""); // Using 0 length string for null type names
        // TODO: Consider handling null in a different manner
        WriteConstant(field.InitialValue ?? 0, writer); // Using 0 for null initial values
    }

    private static void WriteProperty(VbcProperty property, BinaryWriter writer)
    {
        writer.WriteString(property.Name);
        writer.WriteString(property.Type);
        writer.Write(property.HasGetter);
        writer.Write(property.HasSetter);
    }

    /// <summary>
    /// Writes the details of a VbcMethod, including its name, parameters, local variables, and instructions, to a binary stream.
    /// </summary>
    /// <param name="method">The <see cref="VbcMethod"/> instance containing the method's name, parameters, local variables, and instructions to be serialized.</param>
    /// <param name="writer">The <see cref="BinaryWriter"/> instance used to write the method information to the binary stream.</param>
    private static void WriteMethod(VbcMethod method, BinaryWriter writer)
    {
        writer.WriteString(method.Name);
        writer.Write((byte)method.Parameters.Count);
        foreach (var parameter in method.Parameters)
        {
            WriteParameter(parameter, writer);
        }
        
        // writer.Write(method.LocalVariables.Count);
        // foreach (var localVariable in method.LocalVariables)
        // {
            // writer.WriteString(localVariable);
        // }
        
        writer.Write(method.Instructions.Count);
        foreach (var instruction in method.Instructions)
        {
            WriteInstruction(instruction, writer);
        }
    }

    /// <summary>
    /// Writes the details of a <see cref="VbcParameter"/> to a binary stream.
    /// </summary>
    /// <param name="parameter">The <see cref="VbcParameter"/> containing the name and type of the parameter to be written.</param>
    /// <param name="writer">The <see cref="BinaryWriter"/> used to write the parameter details to the binary stream.</param>
    private static void WriteParameter(VbcParameter parameter, BinaryWriter writer)
    {
        writer.WriteString(parameter.Name);
        writer.WriteString(parameter.TypeName);
    }

    /// <summary>
    /// Writes a single low-level instruction and its operand to the given binary writer.
    /// </summary>
    /// <param name="instruction">The <see cref="Instruction"/> to be written, containing the operation code and operand.</param>
    /// <param name="writer">The <see cref="BinaryWriter"/> instance used to write the instruction data to the byte stream.</param>
    private static void WriteInstruction(Instruction instruction, BinaryWriter writer)
    {
        writer.Write((byte)instruction.OpCode);
        writer.Write(instruction.Operand);
    }
}